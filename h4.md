  x) Lue/katso/kuuntele ja tiivistä. (Tässä x-alakohdassa ei tarvitse tehdä testejä tietokoneella, vain lukeminen tai kuunteleminen ja tiivistelmä riittää. Tiivistämiseen riittää muutama ranskalainen viiva.)
        Hammond 2022: Ghidra for Reverse Engineering (PicoCTF 2022 #42 'bbbloat') (Video, noin 20 min)

- Ghidralla voi analysoida binäärejä ja sitä käytiin videolla ratkaistiin Picoctf:än tehtävä
- Videolla avattiin tiedosto ghidralla, siinä löydettiin halutut koodin pätkät kohdasta Windows, Defined strings joka tuo listan määritellyistä stringeistä koodissa
  



a) Asenna Ghidra.
Vaihdoin tässä tehtävässä vihdoin debianista kaliin. Yritin tunnilla asentaa sitä, mutta se oli turhan monimutkaista. Asensin Kali ja 

    sudo apt-get update
    sudo apt-get install ghidra
    ghidra


Sain ghidran käyntiin. Lisäksi Kalissa on muita työkaluja, josta on varmasti hyötyä tulevaisuudessa


b) rever-C. Käänteismallinna packd-binääri C-kielelle Ghidralla. Etsi pääohjelma. Anna muuttujielle kuvaavat nimet. Selitä ohjelman toiminta. Ratkaise tehtävä binääristä, ilman alkuperäistä lähdekoodia. ezbin-challenges.zip

Latasin ezbin-challenges.zip, unzippasin sen ja avasin sen Ghidralla. 

<img width="1409" height="730" alt="kuva" src="https://github.com/user-attachments/assets/efbc5300-66ea-47ee-903e-3f8ccac72d9a" />

Analysoin ja menin kohtaan functions joka on symbol tree:n alla

<img width="247" height="262" alt="kuva" src="https://github.com/user-attachments/assets/51fc8b92-e5ca-486c-b814-4fdda3f7577c" />

Sieltä aloin tutkimaan functiota. 

Tuijotin functioita liiankin pitkään ja koetin etsiä main functiota niiden tekstistä. Sitten tajusin, että siitä ei saa mitään selvää, koska sehän on pakattu. 

Joten uusi yritys. 

Kalilla on jo UPX ladattu eli tarvitsee vain 

    upx -d packd

Poistin varmuudeksi packd tiedoston ja importtasin sen uudestaan. 


<img width="313" height="384" alt="kuva" src="https://github.com/user-attachments/assets/c75faed1-f7ba-4f7a-b5cd-d4087249b129" />

Ja nyt näkyy enemmän ihmisille luettavaa tekstiä.

Menin main functioon. valitsin kohdasta Window, Decompile (ctrl + e shortcut)


<img width="618" height="342" alt="kuva" src="https://github.com/user-attachments/assets/582b14d1-0b83-42ef-99fc-ca09fda2dc6c" />

Aloin siistimään (Kopioin alkuperäisen microon ja muokkasin siellä ihan varmuuden vuoksi)



<img width="1384" height="427" alt="kuva" src="https://github.com/user-attachments/assets/c17d2852-9724-470c-98a6-89d9ff192d79" />


    undefined8 main(void)

sama kuin int main (void), undefined8 on vain placeholder (Netistä ei löydy mitään hyvää käännöstä sanalle placeholder, kertokaa jos keksitte jonkun hyvän

      {
      int cmp;

Määrittää kokonaisluku muuttujan, jota käytetään vertaamiseen kohdassa strcmp


      char passwd [32];
    
Määrittää merkkijonon jonka koko on 32 tavua

      puts("What's the password?");

Kutsuu functiota puts(), joka kysyy "What's the password?" ja se kysyy ja tulostaa syötetyn merkkijonon

    __isoc99_scanf(&DAT_0010201d,local_28);
    cmp = strcmp(passwd,"piilos-AnAnAs");

Aiemmin määritelty muuttuja muutetaan functioksi strcmp joka vertaa kahta eri stringiä


    if (cmp == 0) {
    puts("Yes! That's the password. FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}");
    }

Jos käyttäjän syötetty merkkijono on sama kuin piilos-AnAnAs, niin ohjelma tulostaa "Yes! That's the password. FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}"



    else {
    puts("Sorry, no bonus.");
    }

Jos syöte on mitä tahansa muuta niin tulostaa Sorry, no bonus.

End of the else block.

    return 0;


  }

Palauttaa nollan jos ohjelma päättyy normaalisti.


Salasana on siis piilos-AnAnAs

ja lippu FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}");

Vähän epäselväksi jäi, että kuinka paljon tuollaista koodia voi muokkata ennen kuin se hajoaa/ ei compilaa oikein





c) Jos väärinpäin. Muokkaa passtr-ohjelman binääriä (ilman alkuperäistä lähdekoodia) niin, että se hyväksyy kaikki salasanat paitsi oikean. Osoita testein, että ohjelma toimii. ezbin-challenges.zip



Tunnilla käytiin Ghidran käyttöä, siitä muistan että  
Nykykoodi on: Vertaa syötetty salasana oikeaan salasanaan: jos sama, päästä sisään, jos ei niin älä päästä sisään.
Kun sen kääntää niin se on: jos sama, älä päästä sisään, jos ei, päästä sisään.

Se muistaakseni tunnilta tehtiin vaihtamalla JNZ JN:nnään

Importtasin passtr

<img width="524" height="303" alt="kuva" src="https://github.com/user-attachments/assets/6fa2b560-a7de-4618-982b-7bb0329d60a1" />


Varmistin vielä asian googlamalla "Ghidra JNZ"

Sieltä tuli erittäin kattava ja laadukas [blogi, jossa esitellään Ghidraa](https://jorianwoltjer.com/blog/p/stories/introduction-to-reverse-engineering-with-ghidra#3-changing-instructions-with-ghidra) 

Siinä sanotaankin, että "Here you can see that the if statement is actually JNZ LAB_0010123a in Assembly. This JNZ means 'Jump if Not Zero'. To do the inverse, we would need to change this to JZ which means 'Jump if Zero'."

Eli tuplaklikkaisin main functiossa if lausetta  

<img width="1284" height="269" alt="kuva" src="https://github.com/user-attachments/assets/4d23f82b-6351-4b6e-b5b2-b6c23071e8c6" />

Joka vei kohtaan, jossa assembly ohje  JNZ

Hiiren oikealla näppäimellä sai valikoin josta valitsin Patch instruction


Otin siitä N-kirjaimen pois, jotta siitä tulee JZ 

<img width="624" height="172" alt="kuva" src="https://github.com/user-attachments/assets/042de1bb-7478-4888-a798-b5c104258994" />



JNZ

<img width="619" height="346" alt="kuva" src="https://github.com/user-attachments/assets/2b20f292-a257-402e-b094-53de90b93402" />

JZ

<img width="617" height="358" alt="kuva" src="https://github.com/user-attachments/assets/ee5362b7-b4ee-4ca0-9115-6efcb9cf953d" />




Sitten vielä testaus. Tallensin korjatun version erikseen

<img width="338" height="217" alt="kuva" src="https://github.com/user-attachments/assets/a2cd7c45-294c-425c-8b94-770a8c854456" />


Näin ohjelma toimii käänteisenä kuin sen pitäisi




<img width="763" height="357" alt="kuva" src="https://github.com/user-attachments/assets/45981ebe-f92f-4524-a097-3d8fbdcbf63c" />







d) Nora CrackMe: Käännä binääreiksi Tindall 2023: NoraCodes / crackmes. Lue README.md: älä katso lähdekoodeja, ellet tarvitse niitä apupyöriksi. Näissä tehtävissä binäärejä käänteismallinnetaan. Binäärejä ei muokata, koska muutenhan jokaisen tehtävän ratkaisu olisi vaihtaa palautusarvoksi "return 0".

Luin [README.MD](https://github.com/NoraCodes/crackmes/blob/master/README.md) ja sen tarjoaman  [tutoriaalin](https://nora.codes/tutorial/an-intro-to-x86_64-reverse-engineering/) alun



    git clone https://github.com/NoraCodes/crackmes.git

    

<img width="745" height="450" alt="kuva" src="https://github.com/user-attachments/assets/e7c760d7-0e0f-4417-bad7-cb8054b01274" />


Vielä komento make, jotta niiden kanssa pääsee työskentelemään (melkein unohtui!)

<img width="844" height="743" alt="kuva" src="https://github.com/user-attachments/assets/dbfd1601-c4d6-41d3-8e9c-0409e4aeb709" />








e) Nora crackme01. Ratkaise binääri.

Tein uuden kansion Ghidrassa ja avasin ja analysoin ensimmäisen tehtävän.

Näissä pitää siis saada ohjelmien antaa status 0.



<img width="771" height="496" alt="kuva" src="https://github.com/user-attachments/assets/fa0a887c-150e-49f1-b940-57ba97a9ae22" />



Ghidrassa avautui seuraava näkymä 


<img width="763" height="609" alt="kuva" src="https://github.com/user-attachments/assets/31473655-f2bb-47cc-b898-b88ae84a16cf" />

Ensisilmäyksellä vastaus näyttää olevan password1


Kokeilin ajaa ohjelman

    ./crackme01.64

<img width="323" height="107" alt="kuva" src="https://github.com/user-attachments/assets/5a02b7b1-a368-4c30-b557-c5095f8b3846" />

Siihen tarvitsee syötteen, kokeilin Ghidralla saatua password1

    ./crackme01.64 password1

<img width="369" height="119" alt="kuva" src="https://github.com/user-attachments/assets/b22bb48b-d96c-4bee-8e78-fb120bafa447" />

Se toimi 


Kokeilin huvikseni file ja strings komentoja 

<img width="1278" height="135" alt="kuva" src="https://github.com/user-attachments/assets/e8b72416-4075-4375-947f-9560eb181c78" />




<img width="447" height="576" alt="kuva" src="https://github.com/user-attachments/assets/798e7e3a-8cb8-4803-ae8d-8ef606f7941b" />

Ei tullut vastausta vain näillä, ehkä NSA tietää mitä tekee.





e) Nora crackme01e. Ratkaise binääri.



Kokeilin ensiksi samaan metodia kuin äskeisessä eli 


    ./crackme01e.64 slm!paas.k

  <img width="282" height="124" alt="kuva" src="https://github.com/user-attachments/assets/744c733e-cf0c-4303-93b5-4ab08b910ca3" />

Ja kuten epäilinkin niin ei toiminut. Se kuitenkin antoi lisää dataa:

zsh: event not found: paas.k

Itselleni ei sano mitään ja heti alkuun ajattelin että se voi olla Ghidran muokkaamaa tekstiä.

Hetken ajateltua se ei voi olla näin, koska se on heittomerkkien sisällä.

Ennen googlaamista, tutkin hieman lisää Ghidrassa.

Sieltä ei paljastunut hirveästi mitään joten googlasin ensiksi mikä zsh on. Se on  avoimen lähdekoodin komentotulkki kuten bash

Joten googlasin "bash event not found exclamation" ja tuli [keskustelupalsta](https://unix.stackexchange.com/questions/33339/cant-use-exclamation-mark-in-bash)

Sieltä ei tullut suoraan vastausta, mutta bash ei tykkää jos keskellä merkkijonoa on huutomerkki. Korjaukseksi ehdotetaan käyttämään " tai ' sen ympärillä


Kokeilin 

    ./crackme01e.64 'slm!paas.k'
    ./crackme01e.64 "slm!paas.k"


<img width="425" height="247" alt="kuva" src="https://github.com/user-attachments/assets/34eb0b21-a092-4ecf-9bce-ef746d3cc6a5" />


Josta vain 'slm!paas.k' käy.

En ole mikään bash tai zsh expertti, mutta tämän mukaan zsh tulkitsee stringit jotka ovat '' sisällä tekstiksi.


Importtasin samaan kansioon ja analysoin samalla tavalla kuin äskeisen. 



<img width="671" height="462" alt="kuva" src="https://github.com/user-attachments/assets/5fb67dd8-bc7e-4eb2-93b8-8033f8425be3" />

Ja siellähän se on. Tähän on varmasti joku "puhtaampi" ratkaisu, mutta se toimii näin







f) Nora crackme02. Nimeä pääohjelman muuttujat käänteismallinnetusta binääristä ja selitä ohjelman toiminta. Ratkaise binääri.


g) Vapaaehtoinen: Ja sen yli. Crackme01 on useampia ratkaisuja. Montako löydät? Miksi?
h) Vapaaehtoinen: Pyytämättäkin. Crackme02 on kaksi ratkaisua. Löydätkö molemmat?
i) Vapaaehtoinen, hieman haastavampi: A ray. Nora crackme02e. Ratkaise binääri.



## Lähteet

https://terokarvinen.com

https://terokarvinen.com/sovellusten-hakkerointi/#h4-kaantopaikka-tero

https://github.com/NoraCodes/crackmes/blob/master/README.md

https://nora.codes/tutorial/an-intro-to-x86_64-reverse-engineering/



https://jorianwoltjer.com/blog/p/stories/introduction-to-reverse-engineering-with-ghidra#3-changing-instructions-with-ghidra


https://unix.stackexchange.com/questions/33339/cant-use-exclamation-mark-in-bash
