Speksit

CPU: AMD ryzen 7600x
GPU: AMD radeon 9060 XT 
RAM: 32 GB 
OS: Windows 10 pro

VM: Oracle Virtualbox Debian Bookworm 13.0

Base memory: 4096 mb 
Prosessors: 2 
Storage: 30 GB
  
  
  a) Strings. Lataa ezbin-challenges.zip Aja 'passtr'. Selvitä oikea salasana 'strings' avulla. Selvitä myös lippu. (Ensisijaisesti katsomatta sorsia, jos osaat.)


  Latasin  ezbin-challenges.zip

  Sitten 

      unzip ezbin-challenges.zip
      cd challenges/passtr

Ajoin ./passtr ja se kysyy What's the password?

Ennen kuin aloitin selvittämään katsoin 

    man strings

jotta saan lisätietoa itse komennosta. Se antoi kaikenlaisia parametreja, niistä iski silmään alkuun

    -a
    -U


Aloitin 

    strings passtr -a
    

  

  <img width="898" height="327" alt="Image" src="https://github.com/user-attachments/assets/676ac09d-3b08-48f9-b430-3032cd6a45f8" />

    

<img width="757" height="589" alt="kuva" src="https://github.com/user-attachments/assets/bd22a334-59f6-44ea-9fc2-740ecad5a565" />

Tärkein asia on nämä rivit

What's the password?
%19s
sala-hakkeri-321
Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}

Mutta tämä myös: 
Sorry, no bonus.

Salasana ja lippu löytyi mutta vielä on jokin bonus. Lähdin vielä tutkimaan. Seuraava välitön idea on

    strings passtr -U


  <img width="898" height="327" alt="image" src="https://github.com/user-attachments/assets/0eba7a42-7d3a-44b7-a5f2-ad6ad1caf981" />

Se vaatii lisäparametrejä

    -U {d|l|i|x|e|h}          Specify how to treat UTF-8 encoded unicode characters

joten palaan siihen (mahdollisesti) myöhemmin.

Katsoin muita strings parametreja ja seuraavaksi kokeilin 

    strings passtr -d

    

  <img width="930" height="413" alt="image" src="https://github.com/user-attachments/assets/9e33f43c-3b7f-4282-b7ca-23a86c0f5351" />




Se antoi vain datan eli "siistimmän" version kuin  strings passtr -a

En parhaillaan keksi mitään toista tapaa saad bonusta tehtyä, joten siirryin eteenpäin.








  
  b) Tee passtr.c -ohjelmasta uusi versio, jossa salasana ei näy suoraan sellaisenaan binääristä. Osoita testillä, että salasana ei näy. (Obfuskointi riittää.)

Olen hieman tutustunut C-kieleen, mutta tiedän vain perusteet. Tietoa on kuitenkin jonkin verran:

Haavoittuvuus: salasana on tallennettuna tekstinä (plain text) itse tiedostoon jonka kuka tahansa voi päästä käsiksi yhdellä komennolla.
Lisäksi tehtävänannossa mainitaan, etta obfuskointi riittää. Tiedän kuitenkin sen verran, että obfuskointi ei ole ideaalinen salausmetodi. Nykyään kaikki salasanat on salattu hashilla tai checksumilla. Mutta yksi asia kerrallaan: Teen obfuskoinnin ja jos voin/kykynen niin koitan keksiä paremman tavan.
Eli minun pitää selvittää miten obfuskoida tekstiä, joka on C-kiellellä kirjoitetussa ohjelmassa. En tiedä ollenkaan miten se tehdään, joten päätin googlata sen. Hain: "how to obfuscate text with c" ja tuli paljon tuloksia. Tutkiessani hakutuloksia ei löytynyt suoraviivaista vastausta, joten sitten täytyy tutkia C-kieltä tarkemmin. 

Ongelmana on siis, että salasana on plain textiä ja se pitäisi muuttaa salatummaksi. Ensimmäiseksi tuli mieleen hajoittaa se osiin, jotta se on vaikeampi löytää, koska tällä hetkellä se on helposti luettavissa yhdellä rivillä. Hain: "Split strings in C" ja löytyi https://www.geeksforgeeks.org/java/how-to-split-a-string-in-cc-python-and-java/ 

Osien jako syntaksi

      char str[] = "";

Itse korjaus: 
```c
#include <stdio.h>
#include <string.h>

int main() {
    char password[20];


   char ss1[] = "sa";
   char ss2[] = "la";
   char ss3[] = "-hak";
   char ss4[] = "ke";
   char ss5[] = "ri";
   char ss6[] = "-321";
   
   
    char f1[] = "FLAG{Tero-";
    char f2[] = "d75ee66af0a";
    char f3[] = "68663f15539";
    char f4[] = "ec0f46e3b1}";

    
    char full_pw[20];
    sprintf(full_pw, "%s%s%s%s%s%s", ss1, ss2, ss3, ss4, ss5, ss6);

    // varmuudeksi lippu
    char flag[100];
    sprintf(flag, "%s%s%s%s", f1, f2, f3, f4);

    printf("What's the password?\n");
    scanf("%19s", password);

    if (strcmp(password, full_pw) == 0) {
        printf("Yes! That's the password. %s\n", flag);
    } else {
        printf("Sorry, no bonus.\n");
    }

    return 0;
}
```

Nyt salasana (ja lippu) näkyvät osina.

<img width="763" height="604" alt="passtrfix1" src="https://github.com/user-attachments/assets/2cc7bb5c-0878-4e81-85d4-3d8447b587a0" />



Testasin, että ohjelma toimii

<img width="628" height="101" alt="image" src="https://github.com/user-attachments/assets/ccc9d83a-d64d-4fb6-82e3-09a4ef06d6c1" />

Komento


    strings passtr | grep sala

  ei myöskään toimi enään , koska se on osissa.


Siinä oli perus obfuskointi. Lukiessani siitä törmäsin paljon keskusteluun siitä kuinka huono perusobfuskointi on. Lisäksi näin puhetta XOR:in käytöstä, joka parantaa suojausta, mutta palaan siihen myöhemmin. 


Käytin pohjana tätä https://github.com/KyleBanks/XOREncryption/blob/master/C/main.c

```c

#include <stdio.h>
#include <string.h>

//functio, joka enkoodaa ja dekoodaa s(stringin), joka käy sen jokaisen kirjaimen läpi for loopin avulla
void xor_decode(char *s, char key) {
    for (int i = 0; s[i] != '\0'; i++) {
        s[i] ^= key;
    }
}

int main() {
    char password[20];

   //Sanojen hajottaminen ja enkoodaus availmella 30
    char ss1[] = { 's'^30, 'a'^30, 0 };
    char ss2[] = { 'l'^30, 'a'^30, 0 };
    char ss3[] = { '-'^30, 'h'^30, 'a'^30, 'k'^30, 0 };
    char ss4[] = { 'k'^30, 'e'^30, 0 };
    char ss5[] = { 'r'^30, 'i'^30, 0 };
    char ss6[] = { '-'^30, '3'^30, '2'^30, '1'^30, 0 };

   // Lippuun en koskenut lisää,sen voisi tehdä samalla tavalla
    char f1[] = "FLAG{Tero-";
    char f2[] = "d75ee66af0a";
    char f3[] = "68663f15539";
    char f4[] = "ec0f46e3b1}";

    // sanojen purku
    xor_decode(ss1, 30);
    xor_decode(ss2, 30);
    xor_decode(ss3, 30);
    xor_decode(ss4, 30);
    xor_decode(ss5, 30);
    xor_decode(ss6, 30);

    // Salasanan kokoaminen
    char full_pw[20] = {0};
    strcat(full_pw, ss1);
    strcat(full_pw, ss2);
    strcat(full_pw, ss3);
    strcat(full_pw, ss4);
    strcat(full_pw, ss5);
    strcat(full_pw, ss6);

  // Lipun kokoaminen
    char flag[100] = {0};
    strcat(flag, f1);
    strcat(flag, f2);
    strcat(flag, f3);
    strcat(flag, f4);

   //Tulostus 
    printf("What's the password?\n");
    scanf("%19s", password);

    // check
    if (strcmp(password, full_pw) == 0) {
        printf("Yes! That's the password. %s\n", flag);
    } else {
        printf("Sorry, no bonus.\n");
    }

    return 0;
}

 ```    
 


<img width="780" height="85" alt="image" src="https://github.com/user-attachments/assets/d756bdb8-86a2-44e0-a589-83c2a6f0d18a" />


     strings passtr | grep sala

Ei enää ollenkaan toimi, mutta 


    strings passtr | grep FLAG

Toimii osittain, koska se on hajautettu osiin. Se voisi samalla tavalla XOR-salata, jos tarvitsee





  c) Packd. Aja 'packd' paketista ezbin-challenges.zip. Mikä on salasana? Mikä on lippu? (Tämä tehtävä on hieman haastavampi. Kirjaa ylös kokeilemasi lähestymistavat ja keksimäsi hypoteesit. Toivottavasti pääset itse maaliin, mutta jos et, läpikävely paljastuu tunnilla...)

Navigoin 

    cd /challenges/packd
    ./packd

Tulee vastaan sama: What's the password?


Ajoin 

    strings packd

Odetusti tuli samanlaista kirjainsoppaa kuin edellisessä

<img width="735" height="263" alt="image" src="https://github.com/user-attachments/assets/825af11d-153b-4b4e-bc73-8469ef755854" />

Oleellista

Kuten tehtävän annossa sanottiin tämä on haastavampi. Osa oikean salasanan syötöstä osa näkyy (Yes!) ja lipusta näkyy myös osa  FLAG{Tero-0e3bed0a89d88 (oletetusti myös 51da933c64fefad)


Yes! T,
W. FLAG{Tero-0e3bed0a89d88
51da933c64fefad
S1ry
, no bonus.


Nämä kaksi riviä herätti lopusta kiinnostukseni 

PROT_EXEC|PROT_WRITE failed.
$Info: This file is packed with the UPX executable packer http://upx.sf.net $

Aloin etsimään tietoa. Kävin ensiksi katsomassa sivun http://upx.sf.net. UPX sivun perusteella on avoimen lähdekoodin tiedostojen kompressori eli se pienentää ja nopeuttaa niiden toimintaa. Tämä tieto voi olla relevantti, ehkä ei. Siitä ainakin löytyy tietoa, koska se on open source.


Sitten PROT_EXEC|PROT_WRITE failed. Googlamalla ei löytynyt paljokaan tietoa, vain keskustelupalstojen kysymyksiä usein binäärien liittyen

Tässä välissä kokeilin myös file komentoa

<img width="922" height="48" alt="image" src="https://github.com/user-attachments/assets/5d6efce5-e66d-4dc7-a605-5f2fda2acf6e" />

Se ei (minun silmilleni) paljastanut mitään.


En itse tiedä kummastakaan hirveästi mitään, joten aloitain siitä mistä löytyy eniten tietoa: UPX. 
Sen kommennot löytyvät helposti. Tiedosto on pakattu, joten koitin purkaa sen komennolla: upx -d packd
Se ei toiminut, koska sitä ei ole asennettu. 
Uudestaan yritys

    sudo apt-get install upx
    upx -d packd




<img width="781" height="215" alt="image" src="https://github.com/user-attachments/assets/c4c31900-4f19-4a66-b387-508c318e7ccc" />



Tiedosto on nyt onnistuneesti purettu.

Nyt kokeilin uudestaan file

<img width="1130" height="76" alt="image" src="https://github.com/user-attachments/assets/f202159d-02bd-42a9-90ac-ec9dda38eb18" />

Paljastui enemmän tietoa, tärkeimpänä not stripped eli se sisältää debugaus tietoja, jotka voivat olla hyödyllisiä.

Sen jälkeen kokeilin uudestaan strings:


<img width="657" height="368" alt="image" src="https://github.com/user-attachments/assets/34f9f9e4-5116-48a9-907f-3ad91383fa32" />


Ja voila!

salasana: piilos-AnAnAs


Lippu: FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}


<img width="657" height="368" alt="image" src="https://github.com/user-attachments/assets/c5a8165a-ee5c-48b5-be1d-9fa9d1474a9c" />


testasin vielä salasanaa varmuudeksi 


<img width="675" height="99" alt="image" src="https://github.com/user-attachments/assets/ae4b2c3e-5fe2-4ab5-a1b2-8ae7ab184fc3" />

Tulos oli sama.

Törmäsin tehtävän jälkeen tähän hyödylliseen keskustelun jälkeen 

https://unix.stackexchange.com/questions/418354/understanding-what-a-linux-binary-is-doing









 

  d) Vapaaehtoinen bonus: Cryptopals. Crypto Challenge Set 1. Tätä voi tehdä useamman viikon bonuksena. Jos saat ratkaistua kohdat 1 .. "4. Detect single-character XOR", olet jo astunut salakirjoituksen maailmaan.

  Päätin aloittaa Cryptopals tehtävät.

  1.1 

  <img width="1252" height="510" alt="kuva" src="https://github.com/user-attachments/assets/551dc720-9748-469f-bef7-0055d5011dcb" />


  https://docs.python.org/3/library/base64.html

  Pythonilla on oma base64 kirjasto


  Tehtävässä pitää:

  hex to bytes, bytes to base64 ja lopuksi encodata bytet base 64


```python
import base64


hexS = ""

rawBytes = bytes.fromhex(hexS)


b64_encoded = base64.b64encode(rawBytes)


print(b64_encoded.decode())

```
Palaan myöhemmin loppuihin tehtäviin, koska cryptografia on mielenkiintoista mutta vaikeaa.



## Lähteet

https://terokarvinen.com/

https://terokarvinen.com/sovellusten-hakkerointi/#h3-no-strings-attached-tero

https://www.mankier.com/1/upx

https://www.geeksforgeeks.org/java/how-to-split-a-string-in-cc-python-and-java


https://upx.github.io/

https://github.com/KyleBanks/XOREncryption/blob/master/C/main.c
